import Fuse from 'fuse.js';
import { debounce } from 'lodash';

// ç›´æ¥å®šä¹‰ç±»å‹ï¼Œé¿å…å¤æ‚çš„å¯¼å…¥
type FuseResultMatch = {
  indices: readonly [number, number][];
  value?: string;
  key?: string;
  arrayIndex?: number;
};

// æœç´¢é…ç½®ç±»å‹
export type SearchConfig = {
  threshold: number;
  includeScore: boolean;
  includeMatches: boolean;
  minMatchCharLength: number;
  keys: string[];
};

// æœç´¢ç»“æœç±»å‹
export type SearchResult<T> = {
  item: T;
  score?: number;
  matches?: FuseResultMatch[];
};

// ç¡®ä¿å¯¼å‡º
export type { SearchConfig as SearchConfigType, SearchResult as SearchResultType };

// æœç´¢æ¨¡å¼æšä¸¾
export enum SearchMode {
  FUZZY = 'fuzzy',
  EXACT = 'exact',
  AUTO = 'auto',
  RANGE = 'range'  // æ–°å¢ï¼šæ•°å€¼èŒƒå›´æœç´¢
}

// é»˜è®¤é…ç½®
const DEFAULT_SEARCH_CONFIG: SearchConfig = {
  threshold: 0.3,
  includeScore: true,
  includeMatches: true,
  minMatchCharLength: 1,
  keys: [
    'å‘˜å·¥å§“å',
    'å‘˜å·¥ç¼–å·', 
    'èº«ä»½è¯å·',    // æ·»åŠ èº«ä»½è¯å·
    'éƒ¨é—¨åç§°',
    'èŒä½åç§°',
    'äººå‘˜ç±»åˆ«',
    'ç¼–åˆ¶',
    'è–ªèµ„æœŸé—´åç§°',
    // æ·»åŠ å¸¸ç”¨çš„æ•°å€¼å­—æ®µä»¥ä¾¿æœç´¢
    'å®å‘åˆè®¡',
    'åº”å‘åˆè®¡',
    'æ‰£é™¤åˆè®¡',
    'åŸºæœ¬å·¥èµ„'
  ]
};

// åŠ¨æ€ç”Ÿæˆæœç´¢é…ç½®
export const generateSearchConfig = <T>(data: T[]): SearchConfig => {
  if (!data || data.length === 0) {
    console.log('âš ï¸ [generateSearchConfig] æ•°æ®ä¸ºç©ºï¼Œä½¿ç”¨é»˜è®¤é…ç½®');
    return DEFAULT_SEARCH_CONFIG;
  }

  const firstItem = data[0] as any;
  const allKeys = Object.keys(firstItem);
  
  console.log('ğŸ”§ [generateSearchConfig] åŠ¨æ€ç”Ÿæˆæœç´¢é…ç½®', {
    totalFields: allKeys.length,
    allFields: allKeys.slice(0, 20) // æ˜¾ç¤ºå‰20ä¸ªå­—æ®µ
  });

  // åˆ†ç±»å­—æ®µ
  const textFields: string[] = [];
  const numericFields: string[] = [];
  const priorityFields: string[] = [];
  
  // é«˜ä¼˜å…ˆçº§å­—æ®µï¼ˆé‡è¦çš„ä¸šåŠ¡å­—æ®µï¼‰
  const priorityPatterns = [
    /^å‘˜å·¥å§“å$|^å§“å$/,
    /^å‘˜å·¥ç¼–å·$|^ç¼–å·$/,
    /^èº«ä»½è¯å·$/,
    /^éƒ¨é—¨åç§°$|^éƒ¨é—¨$/,
    /^èŒä½åç§°$|^èŒä½$|^å²—ä½$/,
    /^äººå‘˜ç±»åˆ«$/,
    /^ç¼–åˆ¶$/
  ];

  // æ•°å€¼å­—æ®µæ¨¡å¼
  const numericPatterns = [
    /åˆè®¡$/,
    /å·¥èµ„$/,
    /æ´¥è´´$/,
    /å¥–é‡‘$/,
    /è¡¥è´´$/,
    /æ‰£é™¤$/,
    /é‡‘é¢$/,
    /è´¹ç”¨$/,
    /^åŸºæœ¬/,
    /ä¿é™©$/,
    /å…¬ç§¯é‡‘$/
  ];

  // æ’é™¤å­—æ®µæ¨¡å¼
  const excludePatterns = [
    /^id$|.*id$/i,
    /^key$/,
    /æ—¶é—´$|æ—¥æœŸ$/,
    /åˆ›å»º|æ›´æ–°|ä¿®æ”¹/,
    /^\$|^_/
  ];

  allKeys.forEach(key => {
    // è·³è¿‡æ’é™¤çš„å­—æ®µ
    if (excludePatterns.some(pattern => pattern.test(key))) {
      return;
    }

    const value = firstItem[key];
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯é«˜ä¼˜å…ˆçº§å­—æ®µ
    const isPriority = priorityPatterns.some(pattern => pattern.test(key));
    if (isPriority) {
      priorityFields.push(key);
      return;
    }

    // æ£€æŸ¥æ˜¯å¦æ˜¯æ•°å€¼å­—æ®µ
    const isNumeric = typeof value === 'number' || 
                     (typeof value === 'string' && !isNaN(Number(value)) && value.trim() !== '') ||
                     numericPatterns.some(pattern => pattern.test(key));
    
    if (isNumeric) {
      numericFields.push(key);
    } else if (typeof value === 'string' && value.trim() !== '') {
      textFields.push(key);
    }
  });

  // ç»„åˆæœ€ç»ˆçš„æœç´¢å­—æ®µï¼šé«˜ä¼˜å…ˆçº§ + é‡è¦æ–‡æœ¬å­—æ®µ + é‡è¦æ•°å€¼å­—æ®µ
  const searchKeys = [
    ...priorityFields,
    ...textFields.slice(0, 10), // å–å‰10ä¸ªæ–‡æœ¬å­—æ®µ
    ...numericFields.slice(0, 15) // å–å‰15ä¸ªæ•°å€¼å­—æ®µ
  ];

  console.log('ğŸ”§ [generateSearchConfig] å­—æ®µåˆ†ç±»ç»“æœ', {
    priorityFields: priorityFields.length,
    textFields: textFields.length,
    numericFields: numericFields.length,
    totalSearchKeys: searchKeys.length,
    finalKeys: searchKeys
  });

  return {
    ...DEFAULT_SEARCH_CONFIG,
    keys: searchKeys
  };
};

// æœç´¢å¼•æ“ç±»
export class PayrollSearchEngine<T> {
  private fuse: Fuse<T>;
  private data: T[] = [];
  private config: SearchConfig;

  constructor(data: T[], config: Partial<SearchConfig> = {}) {
    // å…ˆç”ŸæˆåŸºç¡€é…ç½®
    const baseConfig = { ...DEFAULT_SEARCH_CONFIG, ...config };
    
    // å¦‚æœæ²¡æœ‰æä¾›keysæˆ–keysä¸ºç©ºï¼Œåˆ™åŠ¨æ€ç”Ÿæˆ
    if (!config.keys || config.keys.length === 0) {
      const dynamicConfig = generateSearchConfig(data);
      this.config = { ...baseConfig, keys: dynamicConfig.keys };
    } else {
      this.config = baseConfig;
    }
    
    // ç¡®ä¿keyså­˜åœ¨ä¸”æ˜¯æ•°ç»„
    if (!this.config.keys || !Array.isArray(this.config.keys)) {
      this.config.keys = [];
    }
    
    this.data = data;
    this.fuse = new Fuse(data, {
      threshold: this.config.threshold,
      includeScore: this.config.includeScore,
      includeMatches: this.config.includeMatches,
      minMatchCharLength: this.config.minMatchCharLength,
      keys: this.config.keys,
      ignoreLocation: true,
      findAllMatches: true,
    });

    console.log('ğŸš€ [PayrollSearchEngine] æœç´¢å¼•æ“åˆå§‹åŒ–å®Œæˆ', {
      dataLength: data.length,
      searchKeys: this.config.keys.length,
      threshold: this.config.threshold,
      actualKeys: this.config.keys.slice(0, 10)
    });
  }

  updateData(newData: T[]): void {
    this.data = newData;
    
    // å¦‚æœæœ‰æ–°æ•°æ®ï¼Œé‡æ–°ç”Ÿæˆæœç´¢é…ç½®
    if (newData.length > 0) {
      const newConfig = generateSearchConfig(newData);
      this.config = { ...this.config, keys: newConfig.keys };
      
      console.log('ğŸ”„ [updateData] é‡æ–°ç”Ÿæˆæœç´¢é…ç½®', {
        newDataLength: newData.length,
        newSearchKeys: this.config.keys.length,
        sampleKeys: this.config.keys.slice(0, 10)
      });
    }
    
    // ç¡®ä¿keyså­˜åœ¨ä¸”æ˜¯æ•°ç»„
    if (!this.config.keys || !Array.isArray(this.config.keys)) {
      this.config.keys = [];
    }
    
    // é‡æ–°åˆ›å»ºFuseå®ä¾‹
    this.fuse = new Fuse(newData, {
      threshold: this.config.threshold,
      includeScore: this.config.includeScore,
      includeMatches: this.config.includeMatches,
      minMatchCharLength: this.config.minMatchCharLength,
      keys: this.config.keys,
      ignoreLocation: true,
      findAllMatches: true,
    });
  }

  // è·å–å½“å‰æœç´¢é…ç½®ä¿¡æ¯
  getSearchInfo() {
    return {
      searchKeys: this.config.keys,
      dataLength: this.data.length,
      threshold: this.config.threshold
    };
  }

  search(query: string): SearchResult<T>[] {
    console.log(`ğŸ” [PayrollSearchEngine] æœç´¢`, {
      query,
      dataLength: this.data.length,
      keys: this.config.keys,
      sampleData: this.data.slice(0, 1)
    });

    // è¯¦ç»†æ£€æŸ¥æ•°æ®ç»“æ„
    if (this.data.length > 0) {
      const firstItem = this.data[0] as any;
      console.log('ğŸ” [æ•°æ®ç»“æ„æ£€æŸ¥] ç¬¬ä¸€æ¡æ•°æ®çš„æ‰€æœ‰å­—æ®µ:', Object.keys(firstItem));
      console.log('ğŸ” [æ•°æ®ç»“æ„æ£€æŸ¥] æœç´¢å­—æ®µçš„å€¼:', {
        å‘˜å·¥å§“å: firstItem['å‘˜å·¥å§“å'],
        å‘˜å·¥ç¼–å·: firstItem['å‘˜å·¥ç¼–å·'],
        èº«ä»½è¯å·: firstItem['èº«ä»½è¯å·'],
        éƒ¨é—¨åç§°: firstItem['éƒ¨é—¨åç§°'],
        èŒä½åç§°: firstItem['èŒä½åç§°'],
        å®å‘åˆè®¡: firstItem['å®å‘åˆè®¡'],
        åº”å‘åˆè®¡: firstItem['åº”å‘åˆè®¡']
      });
      
      // æ£€æŸ¥å“ªäº›æœç´¢å­—æ®µå®é™…å­˜åœ¨
      const existingKeys = this.config.keys.filter(key => firstItem.hasOwnProperty(key));
      const missingKeys = this.config.keys.filter(key => !firstItem.hasOwnProperty(key));
      console.log('ğŸ” [æ•°æ®ç»“æ„æ£€æŸ¥] å­˜åœ¨çš„æœç´¢å­—æ®µ:', existingKeys);
      console.log('ğŸ” [æ•°æ®ç»“æ„æ£€æŸ¥] ç¼ºå¤±çš„æœç´¢å­—æ®µ:', missingKeys);
    }

    if (!query.trim()) {
      return this.data.map(item => ({ item }));
    }

    const results = this.fuse.search(query);
    console.log(`ğŸ” [PayrollSearchEngine] Fuseæœç´¢ç»“æœ`, {
      query,
      resultsCount: results.length,
      sampleResults: results.slice(0, 2)
    });

    return results.map(result => ({
      item: result.item,
      score: result.score,
      matches: result.matches ? [...result.matches] : undefined
    }));
  }

  searchMultipleKeywords(query: string): SearchResult<T>[] {
    if (!query.trim()) {
      return this.data.map(item => ({ item }));
    }

    const keywords = query.trim().split(/\s+/);
    if (keywords.length === 1) {
      return this.search(query);
    }

    let results = this.data.map(item => ({ item }));
    
    for (const keyword of keywords) {
      const keywordResults = this.search(keyword);
      const keywordItems = new Set(keywordResults.map(r => r.item));
      results = results.filter(r => keywordItems.has(r.item));
    }

    return results;
  }

  exactSearch(query: string): SearchResult<T>[] {
    if (!query.trim()) {
      return this.data.map(item => ({ item }));
    }

    const lowerQuery = query.toLowerCase();
    return this.data
      .filter(item => {
        return this.config.keys.some(key => {
          const value = (item as any)[key];
          if (value == null) return false;
          return String(value).toLowerCase().includes(lowerQuery);
        });
      })
      .map(item => ({ item }));
  }

  // æ–°å¢ï¼šæ•°å€¼èŒƒå›´æœç´¢
  rangeSearch(query: string): SearchResult<T>[] {
    if (!query.trim()) {
      return this.data.map(item => ({ item }));
    }

    console.log('ğŸ”¢ [rangeSearch] å¼€å§‹æ•°å€¼èŒƒå›´æœç´¢', {
      query,
      dataLength: this.data.length,
      sampleData: this.data.slice(0, 1)
    });

    const rangeExpressions = this.parseRangeQuery(query);
    if (rangeExpressions.length === 0) {
      console.log('âš ï¸ [rangeSearch] æœªè¯†åˆ«åˆ°èŒƒå›´è¡¨è¾¾å¼ï¼Œå›é€€åˆ°æ¨¡ç³Šæœç´¢');
      // å¦‚æœæ²¡æœ‰è¯†åˆ«åˆ°èŒƒå›´è¡¨è¾¾å¼ï¼Œå›é€€åˆ°æ¨¡ç³Šæœç´¢
      return this.searchMultipleKeywords(query);
    }

    console.log('ğŸ”¢ [rangeSearch] è§£æçš„èŒƒå›´è¡¨è¾¾å¼:', rangeExpressions);

    const filteredData = this.data.filter(item => {
      // æ‰€æœ‰èŒƒå›´æ¡ä»¶éƒ½å¿…é¡»æ»¡è¶³ï¼ˆANDé€»è¾‘ï¼‰
      const result = rangeExpressions.every(expr => this.evaluateRangeExpression(item, expr));
      
      if (result) {
        console.log('âœ… [rangeSearch] åŒ¹é…çš„æ•°æ®é¡¹:', {
          item: (item as any)['å‘˜å·¥å§“å'] || 'Unknown',
          expressions: rangeExpressions.map(expr => ({
            field: expr.field,
            operator: expr.operator,
            value: expr.value,
            fieldValue: (item as any)[expr.field]
          }))
        });
      }
      
      return result;
    });

    console.log('ğŸ”¢ [rangeSearch] æœç´¢å®Œæˆ', {
      totalData: this.data.length,
      filteredCount: filteredData.length,
      expressions: rangeExpressions
    });

    return filteredData.map(item => ({ item }));
  }

  // è§£æèŒƒå›´æŸ¥è¯¢è¡¨è¾¾å¼
  private parseRangeQuery(query: string): Array<{
    field: string;
    operator: '>' | '<' | '>=' | '<=' | '=' | '!=';
    value: number;
    originalText: string;
  }> {
    console.log('ğŸ” [parseRangeQuery] å¼€å§‹è§£æèŒƒå›´æŸ¥è¯¢:', query);
    
    const expressions: Array<{
      field: string;
      operator: '>' | '<' | '>=' | '<=' | '=' | '!=';
      value: number;
      originalText: string;
    }> = [];

    // åŒ¹é…å„ç§èŒƒå›´è¡¨è¾¾å¼æ¨¡å¼
    const patterns = [
      // å­—æ®µå>æ•°å€¼ æˆ– å­—æ®µå > æ•°å€¼
      /([^><=!]+)\s*(>=|<=|>|<|!=|=)\s*(\d+(?:\.\d+)?)/g,
      // æ•°å€¼<å­—æ®µå (åå‘è¡¨è¾¾å¼)
      /(\d+(?:\.\d+)?)\s*(>=|<=|>|<|!=|=)\s*([^><=!]+)/g
    ];

    for (let patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
      const pattern = patterns[patternIndex];
      console.log(`ğŸ” [parseRangeQuery] å°è¯•æ¨¡å¼ ${patternIndex + 1}:`, pattern);
      
      let match;
      while ((match = pattern.exec(query)) !== null) {
        const [fullMatch, left, operator, right] = match;
        console.log('ğŸ” [parseRangeQuery] æ‰¾åˆ°åŒ¹é…:', { fullMatch, left, operator, right });
        
        let field: string;
        let value: number;
        let actualOperator = operator as '>' | '<' | '>=' | '<=' | '=' | '!=';
        
        // åˆ¤æ–­æ˜¯æ­£å‘è¿˜æ˜¯åå‘è¡¨è¾¾å¼
        if (isNaN(Number(left))) {
          // æ­£å‘ï¼šå­—æ®µå æ“ä½œç¬¦ æ•°å€¼
          field = left.trim();
          value = parseFloat(right);
          console.log('ğŸ” [parseRangeQuery] æ­£å‘è¡¨è¾¾å¼:', { field, operator, value });
        } else {
          // åå‘ï¼šæ•°å€¼ æ“ä½œç¬¦ å­—æ®µå (éœ€è¦ç¿»è½¬æ“ä½œç¬¦)
          field = right.trim();
          value = parseFloat(left);
          // ç¿»è½¬æ“ä½œç¬¦
          const operatorMap: Record<string, '>' | '<' | '>=' | '<=' | '=' | '!'> = {
            '>': '<',
            '<': '>',
            '>=': '<=',
            '<=': '>=',
            '=': '=',
            '!=': '!='
          };
          actualOperator = operatorMap[operator] as '>' | '<' | '>=' | '<=' | '=' | '!=';
          console.log('ğŸ” [parseRangeQuery] åå‘è¡¨è¾¾å¼:', { field, originalOperator: operator, flippedOperator: actualOperator, value });
        }

        // æŸ¥æ‰¾åŒ¹é…çš„æ•°æ®å­—æ®µ
        const matchedKey = this.findMatchingDataKey(field);
        if (matchedKey) {
          const expression = {
            field: matchedKey,
            operator: actualOperator,
            value,
            originalText: fullMatch
          };
          expressions.push(expression);
          console.log('âœ… [parseRangeQuery] æ·»åŠ è¡¨è¾¾å¼:', expression);
        } else {
          console.log('âŒ [parseRangeQuery] æœªæ‰¾åˆ°åŒ¹é…çš„å­—æ®µ:', field);
        }
      }
    }

    console.log('ğŸ” [parseRangeQuery] è§£æå®Œæˆï¼Œæ‰¾åˆ°è¡¨è¾¾å¼:', expressions);
    return expressions;
  }

  // æŸ¥æ‰¾åŒ¹é…çš„æ•°æ®å­—æ®µé”®
  private findMatchingDataKey(searchField: string): string | null {
    const lowerSearchField = searchField.toLowerCase().trim();
    
    console.log('ğŸ” [findMatchingDataKey] æŸ¥æ‰¾å­—æ®µåŒ¹é…', {
      searchField,
      lowerSearchField,
      configKeys: this.config.keys,
      dataLength: this.data.length
    });

    // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰ç›´æ¥åŒ¹é…çš„é”®
    const directMatch = this.config.keys.find(key => 
      key.toLowerCase() === lowerSearchField
    );
    if (directMatch) {
      console.log('âœ… [findMatchingDataKey] ç›´æ¥åŒ¹é…:', directMatch);
      return directMatch;
    }

    // æ£€æŸ¥åŒ…å«å…³ç³»
    const containsMatch = this.config.keys.find(key => 
      key.toLowerCase().includes(lowerSearchField) || 
      lowerSearchField.includes(key.toLowerCase())
    );
    if (containsMatch) {
      console.log('âœ… [findMatchingDataKey] åŒ…å«åŒ¹é…:', containsMatch);
      return containsMatch;
    }

    // è·å–æ‰€æœ‰å¯èƒ½çš„æ•°å€¼å­—æ®µï¼ˆé€šè¿‡æ£€æŸ¥ç¬¬ä¸€æ¡æ•°æ®ï¼‰
    if (this.data.length > 0) {
      const firstItem = this.data[0] as any;
      const allKeys = Object.keys(firstItem);
      const numericKeys = allKeys.filter(key => {
        const value = firstItem[key];
        const isNumeric = typeof value === 'number' || 
                         (typeof value === 'string' && !isNaN(Number(value)) && value.trim() !== '');
        return isNumeric;
      });

      console.log('ğŸ” [findMatchingDataKey] æ‰€æœ‰å­—æ®µ:', allKeys.slice(0, 10));
      console.log('ğŸ” [findMatchingDataKey] æ•°å€¼å­—æ®µ:', numericKeys.slice(0, 10));
      console.log('ğŸ” [findMatchingDataKey] ç¬¬ä¸€æ¡æ•°æ®ç¤ºä¾‹:', {
        å‘˜å·¥å§“å: firstItem['å‘˜å·¥å§“å'],
        å®å‘åˆè®¡: firstItem['å®å‘åˆè®¡'],
        åº”å‘åˆè®¡: firstItem['åº”å‘åˆè®¡'],
        åŸºæœ¬å·¥èµ„: firstItem['åŸºæœ¬å·¥èµ„']
      });

      const numericMatch = numericKeys.find(key => 
        key.toLowerCase().includes(lowerSearchField) || 
        lowerSearchField.includes(key.toLowerCase())
      );
      if (numericMatch) {
        console.log('âœ… [findMatchingDataKey] æ•°å€¼å­—æ®µåŒ¹é…:', numericMatch, 'å€¼:', firstItem[numericMatch]);
        return numericMatch;
      }
    }

    console.log('âŒ [findMatchingDataKey] æœªæ‰¾åˆ°åŒ¹é…å­—æ®µ');
    return null;
  }

  // è¯„ä¼°èŒƒå›´è¡¨è¾¾å¼
  private evaluateRangeExpression(item: any, expr: {
    field: string;
    operator: '>' | '<' | '>=' | '<=' | '=' | '!=';
    value: number;
  }): boolean {
    const fieldValue = item[expr.field];
    
    console.log('ğŸ”¢ [evaluateRangeExpression] è¯„ä¼°è¡¨è¾¾å¼', {
      field: expr.field,
      operator: expr.operator,
      targetValue: expr.value,
      fieldValue,
      fieldValueType: typeof fieldValue
    });

    if (fieldValue == null) {
      console.log('âŒ [evaluateRangeExpression] å­—æ®µå€¼ä¸ºnullæˆ–undefined');
      return false;
    }

    const numValue = typeof fieldValue === 'number' ? fieldValue : parseFloat(String(fieldValue));
    if (isNaN(numValue)) {
      console.log('âŒ [evaluateRangeExpression] æ— æ³•è½¬æ¢ä¸ºæ•°å€¼', {
        originalValue: fieldValue,
        stringValue: String(fieldValue),
        parsedValue: numValue
      });
      return false;
    }

    let result = false;
    switch (expr.operator) {
      case '>':
        result = numValue > expr.value;
        break;
      case '<':
        result = numValue < expr.value;
        break;
      case '>=':
        result = numValue >= expr.value;
        break;
      case '<=':
        result = numValue <= expr.value;
        break;
      case '=':
        result = numValue === expr.value;
        break;
      case '!=':
        result = numValue !== expr.value;
        break;
      default:
        result = false;
    }

    console.log('ğŸ”¢ [evaluateRangeExpression] è¯„ä¼°ç»“æœ', {
      expression: `${numValue} ${expr.operator} ${expr.value}`,
      result
    });

    return result;
  }

  getSuggestions(query: string, limit: number = 5): string[] {
    if (!query.trim()) return [];

    const suggestions = new Set<string>();
    const lowerQuery = query.toLowerCase();

    this.data.forEach(item => {
      this.config.keys.forEach(key => {
        const value = (item as any)[key];
        if (value != null) {
          const strValue = String(value);
          if (strValue.toLowerCase().includes(lowerQuery)) {
            suggestions.add(strValue);
          }
        }
      });
    });

    return Array.from(suggestions).slice(0, limit);
  }
}

// é˜²æŠ–æœç´¢å‡½æ•°
export const createDebouncedSearch = <T>(
  searchEngine: PayrollSearchEngine<T>,
  delay: number = 300
) => {
  return debounce((query: string, callback: (results: SearchResult<T>[]) => void) => {
    console.log('ğŸ• [createDebouncedSearch] æ‰§è¡Œé˜²æŠ–æœç´¢', { query });
    // ä½¿ç”¨æ™ºèƒ½æœç´¢æ›¿ä»£å›ºå®šçš„å¤šå…³é”®è¯æœç´¢
    const results = smartSearch(searchEngine, query, SearchMode.AUTO);
    callback(results);
  }, delay);
};

// é«˜äº®å·¥å…·å‡½æ•°
export const getHighlightRanges = (text: string, matches?: FuseResultMatch[]): Array<[number, number]> => {
  if (!matches || !text) return [];

  const ranges: Array<[number, number]> = [];
  
  matches.forEach(match => {
    if (match.indices) {
      match.indices.forEach(([start, end]) => {
        ranges.push([start, end + 1]);
      });
    }
  });

  ranges.sort((a, b) => a[0] - b[0]);
  const merged: Array<[number, number]> = [];
  
  for (const range of ranges) {
    if (merged.length === 0 || merged[merged.length - 1][1] < range[0]) {
      merged.push(range);
    } else {
      merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], range[1]);
    }
  }

  return merged;
};

// æ™ºèƒ½æœç´¢å‡½æ•°
export const smartSearch = <T>(
  searchEngine: PayrollSearchEngine<T>,
  query: string,
  mode: SearchMode = SearchMode.AUTO
): SearchResult<T>[] => {
  console.log('ğŸ¤– [smartSearch] å¼€å§‹æ™ºèƒ½æœç´¢', { query, mode });
  
  if (!query.trim()) {
    return searchEngine.search('');
  }

  if (mode === SearchMode.AUTO) {
    console.log('ğŸ¤– [smartSearch] è‡ªåŠ¨æ¨¡å¼ï¼Œå¼€å§‹æ£€æŸ¥æœç´¢ç±»å‹');
    
    // æ£€æŸ¥æ˜¯å¦åŒ…å«æ•°å€¼èŒƒå›´è¡¨è¾¾å¼
    if (containsRangeExpression(query)) {
      console.log('ğŸ”¢ [smartSearch] æ£€æµ‹åˆ°æ•°å€¼èŒƒå›´è¡¨è¾¾å¼ï¼Œä½¿ç”¨èŒƒå›´æœç´¢');
      return searchEngine.rangeSearch(query);
    }
    
    if (query.includes('"')) {
      console.log('ğŸ¯ [smartSearch] æ£€æµ‹åˆ°å¼•å·ï¼Œä½¿ç”¨ç²¾ç¡®æœç´¢');
      const exactQuery = query.replace(/"/g, '');
      return searchEngine.exactSearch(exactQuery);
    }
    if (query.length <= 2) {
      console.log('ğŸ¯ [smartSearch] çŸ­æŸ¥è¯¢ï¼Œä½¿ç”¨ç²¾ç¡®æœç´¢');
      return searchEngine.exactSearch(query);
    }
    console.log('ğŸ” [smartSearch] ä½¿ç”¨å¤šå…³é”®è¯æ¨¡ç³Šæœç´¢');
    return searchEngine.searchMultipleKeywords(query);
  }

  console.log('ğŸ›ï¸ [smartSearch] æ‰‹åŠ¨æ¨¡å¼:', mode);
  switch (mode) {
    case SearchMode.EXACT:
      return searchEngine.exactSearch(query);
    case SearchMode.FUZZY:
      return searchEngine.searchMultipleKeywords(query);
    case SearchMode.RANGE:
      return searchEngine.rangeSearch(query);
    default:
      return searchEngine.searchMultipleKeywords(query);
  }
};

// æ£€æŸ¥æŸ¥è¯¢æ˜¯å¦åŒ…å«æ•°å€¼èŒƒå›´è¡¨è¾¾å¼
export const containsRangeExpression = (query: string): boolean => {
  console.log('ğŸ” [containsRangeExpression] æ£€æŸ¥æ˜¯å¦åŒ…å«èŒƒå›´è¡¨è¾¾å¼:', query);
  
  const rangePatterns = [
    /[^><=!]+\s*(>=|<=|>|<|!=|=)\s*\d+(?:\.\d+)?/,  // å­—æ®µå æ“ä½œç¬¦ æ•°å€¼
    /\d+(?:\.\d+)?\s*(>=|<=|>|<|!=|=)\s*[^><=!]+/   // æ•°å€¼ æ“ä½œç¬¦ å­—æ®µå
  ];
  
  const result = rangePatterns.some((pattern, index) => {
    const matches = pattern.test(query);
    console.log(`ğŸ” [containsRangeExpression] æ¨¡å¼ ${index + 1} (${pattern}) åŒ¹é…ç»“æœ:`, matches);
    return matches;
  });
  
  console.log('ğŸ” [containsRangeExpression] æœ€ç»ˆç»“æœ:', result);
  return result;
}; 