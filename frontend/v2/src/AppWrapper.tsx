import React, { useEffect, useMemo, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { RouterProvider, type createBrowserRouter } from 'react-router-dom';
import { App } from 'antd';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
// Stagewise toolbar integration (development only)
import { StagewiseToolbar } from '@stagewise/toolbar-react';
import { ReactPlugin } from '@stagewise-plugins/react';
import usePayrollConfigStore from './store/payrollConfigStore';
import useHrLookupStore from './store/hrLookupStore';
import { fetchAllLookupTypesAndCache } from './services/lookupService';

// ÂØºÂÖ• Redux hooks Âíå selectors
import { useSelector, useDispatch } from 'react-redux';
import {
  selectChatbotIsLoading,
  selectChatbotIsEnabled,
  selectChatbotIsConfigured,
  selectChatbotToken,
  selectChatbotBaseUrl,
  selectChatbotCustomCss,
  selectChatbotCustomJs,
  selectChatbotSystemVariables
} from './store/chatbotConfigSlice';
import { fetchCurrentUserDetails, rehydrateAuth } from './store/authSlice';
import { jwtDecode } from 'jwt-decode';
import type { RootState, AppDispatch } from './store'; // ÂØºÂÖ• RootState Âíå AppDispatch Á±ªÂûã

type AppRouter = ReturnType<typeof createBrowserRouter>;

interface AppWrapperProps {
  router: AppRouter;
}

const queryClient = new QueryClient();

// Define a placeholder nonce. In a real application, this should be dynamically generated by the server.
// const CSP_NONCE = 'ZWNhZGE5YTEtOGQwMC00ZGQ1LWEzZDQtZWU3YWM2OWQwMzI0'; // Removed hardcoded nonce

const AppWrapper: React.FC<AppWrapperProps> = ({ router }) => {
  const dispatch = useDispatch<AppDispatch>();
  
  // ‰ªé Redux store Ëé∑ÂèñËÆ§ËØÅÁä∂ÊÄÅ
  const authToken = useSelector((state: RootState) => state.auth.authToken);
  const currentUser = useSelector((state: RootState) => state.auth.currentUser);
  const currentUserNumericId = useSelector((state: RootState) => state.auth.currentUserNumericId);
  const isLoadingUser = useSelector((state: RootState) => state.auth.isLoadingUser);
  
  const fetchPayrollConfigs = usePayrollConfigStore(state => state.fetchComponentDefinitions);
  const fetchHrLookups = useHrLookupStore(state => state.fetchLookup);

  // ‰ªé Redux store ‰∏≠Ëé∑Âèñ chatbot ÈÖçÁΩÆÁä∂ÊÄÅ
  const chatbotIsLoading = useSelector(selectChatbotIsLoading);
  const chatbotIsEnabled = useSelector(selectChatbotIsEnabled);
  const chatbotIsConfigured = useSelector(selectChatbotIsConfigured);
  const chatbotConfigToken = useSelector(selectChatbotToken);
  const chatbotConfigBaseUrl = useSelector(selectChatbotBaseUrl);
  const chatbotConfigCustomCss = useSelector(selectChatbotCustomCss);
  const chatbotConfigCustomJs = useSelector(selectChatbotCustomJs);
  const chatbotSystemVariables = useSelector(selectChatbotSystemVariables);

  // ‰ΩøÁî®Áî®Êà∑ÈÖçÁΩÆÁöÑbaseUrlÊù•ÊûÑÂª∫ËÑöÊú¨URLÔºå‰∏çÂÜç‰ΩøÁî®Á°¨ÁºñÁ†ÅÁöÑURL
  const DIFY_EMBED_SCRIPT_SRC = chatbotConfigBaseUrl ?
    `${chatbotConfigBaseUrl.replace(/\/$/, '')}/embed.min.js` :
    "";

  const chatbotSystemVariablesJson = useMemo(() => JSON.stringify(chatbotSystemVariables), [chatbotSystemVariables]);

  // ËÆ§ËØÅÂàùÂßãÂåñÈÄªËæë
  const initializeAuth = useCallback(() => {
    // Â∞ùËØï‰ªé localStorage ÊÅ¢Â§çËÆ§ËØÅÁä∂ÊÄÅ
    try {
      const storedAuthData = localStorage.getItem('auth-storage');
      if (storedAuthData) {
        const parsedAuthData = JSON.parse(storedAuthData);
        
        // Ê£ÄÊü• token ÊòØÂê¶ËøáÊúü
        if (parsedAuthData.authToken) {
          const decodedToken = jwtDecode<{ exp?: number }>(parsedAuthData.authToken);
          const currentTime = Date.now() / 1000;
          
          if (decodedToken.exp && decodedToken.exp < currentTime) {
            // Token ËøáÊúüÔºåÊ∏ÖÈô§Â≠òÂÇ®
            localStorage.removeItem('auth-storage');
            return;
          }
          
          // Token ÊúâÊïàÔºåÊÅ¢Â§çÁä∂ÊÄÅ
          dispatch(rehydrateAuth(parsedAuthData));
          
          // Â¶ÇÊûúÊúâÁî®Êà∑ IDÔºåËé∑ÂèñÊúÄÊñ∞Áî®Êà∑‰ø°ÊÅØ
          if (parsedAuthData.currentUserNumericId) {
            dispatch(fetchCurrentUserDetails(parsedAuthData.currentUserNumericId));
          }
        }
      }
    } catch (error) {
      console.error('Error initializing auth:', error);
      localStorage.removeItem('auth-storage');
    }
  }, [dispatch]);

  useEffect(() => {
    initializeAuth();
  }, [initializeAuth]);

  useEffect(() => {
    if (authToken) {
      fetchPayrollConfigs();
    } else {
    }
  }, [authToken, fetchPayrollConfigs]);

  useEffect(() => {
    if (authToken) {
      
      // üöÄ ‰ºòÂåñÔºöÂàÜÊâπÂä†ËΩΩÔºåÂáèÂ∞ëÂπ∂ÂèëËØ∑Ê±Ç
      const loadLookupsBatch = async () => {
        try {
          // Á¨¨‰∏ÄÊâπÔºöÊúÄÈáçË¶ÅÁöÑÂü∫Á°ÄÊï∞ÊçÆ
          await Promise.all([
            fetchHrLookups('genders'),
            fetchHrLookups('departments'),
            fetchHrLookups('personnelCategories')
          ]);
          
          // Âª∂Ëøü100msÂêéÂä†ËΩΩÁ¨¨‰∫åÊâπ
          setTimeout(async () => {
            await Promise.all([
              fetchHrLookups('maritalStatuses'),
              fetchHrLookups('educationLevels'),
              fetchHrLookups('employmentTypes'),
              fetchHrLookups('employeeStatuses')
            ]);
          }, 100);
          
        } catch (error) {
        }
      };
      
      loadLookupsBatch();
    } else {
    }
  }, [authToken, fetchHrLookups]);

  useEffect(() => {
    if (authToken) {
      fetchAllLookupTypesAndCache();
    } else {
    }
  }, [authToken]);

  useEffect(() => {
    //   '[AppWrapper:useEffect-authWatcher] Auth state changed:',
    //   {
    //     isAuthenticated: !!authToken,
    //     currentUser: currentUser ? currentUser.username : null,
    //     isLoadingUser,
    //   }
    // );
  }, [authToken, currentUser, isLoadingUser]);

  // --- AI Chatbot Integration useEffect Start ---
  useEffect(() => {

    if (chatbotIsLoading) {
      return;
    }

    const scriptIdToUse = chatbotConfigToken || 'dify-chatbot-default-id';

    const cleanupChatbotElements = () => {
      const existingScript = document.getElementById(scriptIdToUse);
      if (existingScript) existingScript.remove();
      const existingConfigScript = document.getElementById('dify-chatbot-config');
      if (existingConfigScript) existingConfigScript.remove();
      const existingCustomStyle = document.getElementById('chatbot-custom-style');
      if (existingCustomStyle) existingCustomStyle.remove();
      const existingCustomLogic = document.getElementById('chatbot-custom-js');
      if (existingCustomLogic) existingCustomLogic.remove();
      const difyWidgetBubble = document.getElementById('dify-chatbot-bubble-button');
      if (difyWidgetBubble) difyWidgetBubble.remove();
      const difyChatbotRoot = document.querySelector('div[id^="dify-chatbotroot-"]');
      if (difyChatbotRoot) difyChatbotRoot.remove();
    };

    if (chatbotIsEnabled && chatbotIsConfigured && chatbotConfigToken && DIFY_EMBED_SCRIPT_SRC && DIFY_EMBED_SCRIPT_SRC.trim() !== '') {
      cleanupChatbotElements();

      const configScript = document.createElement('script');
      configScript.id = 'dify-chatbot-config';
      configScript.nonce = (window as any).__CSP_NONCE__ || ''; // Use global nonce
      const chatbotWindowConfig: { token: string; baseUrl?: string; system_variables: Record<string, any>; dynamicScript?: boolean } = {
        token: chatbotConfigToken!,
        baseUrl: chatbotConfigBaseUrl,
        system_variables: {},
        dynamicScript: true,
      };
      if (chatbotSystemVariables && Array.isArray(chatbotSystemVariables)) {
        chatbotSystemVariables.forEach(sv => {
          if (sv.key && sv.value !== undefined) {
            chatbotWindowConfig.system_variables[sv.key] = sv.value;
          }
        });
      }
      configScript.innerHTML = `window.difyChatbotConfig = ${JSON.stringify(chatbotWindowConfig)};`;
      document.head.appendChild(configScript);

      if (chatbotConfigCustomCss) {
        const styleElement = document.createElement('style');
        styleElement.id = 'chatbot-custom-style';
        styleElement.textContent = chatbotConfigCustomCss;
        styleElement.nonce = (window as any).__CSP_NONCE__ || ''; // Use global nonce
        document.head.appendChild(styleElement);
      }

      if (chatbotConfigCustomJs) {
        const customScriptElement = document.createElement('script');
        customScriptElement.id = 'chatbot-custom-js';
        customScriptElement.textContent = chatbotConfigCustomJs;
        customScriptElement.nonce = (window as any).__CSP_NONCE__ || ''; // Use global nonce
        document.head.appendChild(customScriptElement);
      }

      const embedScript = document.createElement('script');
      embedScript.src = DIFY_EMBED_SCRIPT_SRC;
      embedScript.id = scriptIdToUse;
      embedScript.defer = true;
      embedScript.onload = () => {
      };
      embedScript.onerror = () => {
      };
      document.head.appendChild(embedScript);

    } else {
      cleanupChatbotElements();
    }

    return () => {
      cleanupChatbotElements();
    };
  }, [
    chatbotIsLoading,
    chatbotIsEnabled,
    chatbotIsConfigured,
    chatbotConfigToken,
    chatbotConfigBaseUrl,
    chatbotConfigCustomCss,
    chatbotConfigCustomJs,
    chatbotSystemVariablesJson,
  ]);
  // --- AI Chatbot Integration useEffect End ---

  // Stagewise configuration
  const stagewiseConfig = {
    plugins: [ReactPlugin]
  };

  return (
    // <React.StrictMode> // StrictMode in main.tsx is already commented out
      <QueryClientProvider client={queryClient}>
        <App>
          <RouterProvider router={router} />
          {import.meta.env.DEV && (
            <StagewiseToolbar config={stagewiseConfig} />
          )}
        </App>
      </QueryClientProvider>
    // </React.StrictMode>
  );
};

export default AppWrapper; 