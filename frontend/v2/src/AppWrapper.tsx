import React, { useEffect, useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { RouterProvider, type createBrowserRouter } from 'react-router-dom';
import { App } from 'antd';
import { useAuthStore } from './store/authStore';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import usePayrollConfigStore from './store/payrollConfigStore';
import useHrLookupStore from './store/hrLookupStore';
import { fetchAllLookupTypesAndCache } from './services/lookupService';

// å¯¼å…¥ Redux hooks å’Œ selectors
import { useSelector } from 'react-redux';
import {
  selectChatbotIsLoading,
  selectChatbotIsEnabled,
  selectChatbotIsConfigured,
  selectChatbotToken,
  selectChatbotBaseUrl,
  selectChatbotCustomCss,
  selectChatbotCustomJs,
  selectChatbotSystemVariables
} from './store/chatbotConfigSlice';
import type { RootState } from './store'; // å¯¼å…¥ RootState ç±»åž‹

type AppRouter = ReturnType<typeof createBrowserRouter>;

interface AppWrapperProps {
  router: AppRouter;
}

const queryClient = new QueryClient();

// Define a placeholder nonce. In a real application, this should be dynamically generated by the server.
// const CSP_NONCE = 'ZWNhZGE5YTEtOGQwMC00ZGQ1LWEzZDQtZWU3YWM2OWQwMzI0'; // Removed hardcoded nonce

const AppWrapper: React.FC<AppWrapperProps> = ({ router }) => {
  const initializeAuth = useAuthStore(state => state.initializeAuth);
  const authToken = useAuthStore(state => state.authToken);
  const currentUser = useAuthStore(state => state.currentUser);
  const isLoadingUser = useAuthStore(state => state.isLoadingUser);
  const fetchPayrollConfigs = usePayrollConfigStore(state => state.fetchComponentDefinitions);
  const fetchHrLookups = useHrLookupStore(state => state.fetchLookup);

  // ä»Ž Redux store ä¸­èŽ·å– chatbot é…ç½®çŠ¶æ€
  const chatbotIsLoading = useSelector(selectChatbotIsLoading);
  const chatbotIsEnabled = useSelector(selectChatbotIsEnabled);
  const chatbotIsConfigured = useSelector(selectChatbotIsConfigured);
  const chatbotConfigToken = useSelector(selectChatbotToken);
  const chatbotConfigBaseUrl = useSelector(selectChatbotBaseUrl);
  const chatbotConfigCustomCss = useSelector(selectChatbotCustomCss);
  const chatbotConfigCustomJs = useSelector(selectChatbotCustomJs);
  const chatbotSystemVariables = useSelector(selectChatbotSystemVariables);

  // ä½¿ç”¨ç”¨æˆ·é…ç½®çš„baseUrlæ¥æž„å»ºè„šæœ¬URLï¼Œä¸å†ä½¿ç”¨ç¡¬ç¼–ç çš„URL
  const DIFY_EMBED_SCRIPT_SRC = chatbotConfigBaseUrl ?
    `${chatbotConfigBaseUrl.replace(/\/$/, '')}/embed.min.js` :
    "";

  const chatbotSystemVariablesJson = useMemo(() => JSON.stringify(chatbotSystemVariables), [chatbotSystemVariables]);

  useEffect(() => {
    initializeAuth();
  }, [initializeAuth]);

  useEffect(() => {
    if (authToken) {
      fetchPayrollConfigs();
    } else {
    }
  }, [authToken, fetchPayrollConfigs]);

  useEffect(() => {
    if (authToken) {
      
      // ðŸš€ ä¼˜åŒ–ï¼šåˆ†æ‰¹åŠ è½½ï¼Œå‡å°‘å¹¶å‘è¯·æ±‚
      const loadLookupsBatch = async () => {
        try {
          // ç¬¬ä¸€æ‰¹ï¼šæœ€é‡è¦çš„åŸºç¡€æ•°æ®
          await Promise.all([
            fetchHrLookups('genders'),
            fetchHrLookups('departments'),
            fetchHrLookups('personnelCategories')
          ]);
          
          // å»¶è¿Ÿ100msåŽåŠ è½½ç¬¬äºŒæ‰¹
          setTimeout(async () => {
            await Promise.all([
              fetchHrLookups('maritalStatuses'),
              fetchHrLookups('educationLevels'),
              fetchHrLookups('employmentTypes'),
              fetchHrLookups('employeeStatuses')
            ]);
          }, 100);
          
        } catch (error) {
        }
      };
      
      loadLookupsBatch();
    } else {
    }
  }, [authToken, fetchHrLookups]);

  useEffect(() => {
    if (authToken) {
      fetchAllLookupTypesAndCache();
    } else {
    }
  }, [authToken]);

  useEffect(() => {
    //   '[AppWrapper:useEffect-authWatcher] Auth state changed:',
    //   {
    //     isAuthenticated: !!authToken,
    //     currentUser: currentUser ? currentUser.username : null,
    //     isLoadingUser,
    //   }
    // );
  }, [authToken, currentUser, isLoadingUser]);

  // --- AI Chatbot Integration useEffect Start ---
  useEffect(() => {

    if (chatbotIsLoading) {
      return;
    }

    const scriptIdToUse = chatbotConfigToken || 'dify-chatbot-default-id';

    const cleanupChatbotElements = () => {
      const existingScript = document.getElementById(scriptIdToUse);
      if (existingScript) existingScript.remove();
      const existingConfigScript = document.getElementById('dify-chatbot-config');
      if (existingConfigScript) existingConfigScript.remove();
      const existingCustomStyle = document.getElementById('chatbot-custom-style');
      if (existingCustomStyle) existingCustomStyle.remove();
      const existingCustomLogic = document.getElementById('chatbot-custom-js');
      if (existingCustomLogic) existingCustomLogic.remove();
      const difyWidgetBubble = document.getElementById('dify-chatbot-bubble-button');
      if (difyWidgetBubble) difyWidgetBubble.remove();
      const difyChatbotRoot = document.querySelector('div[id^="dify-chatbotroot-"]');
      if (difyChatbotRoot) difyChatbotRoot.remove();
    };

    if (chatbotIsEnabled && chatbotIsConfigured && chatbotConfigToken && DIFY_EMBED_SCRIPT_SRC && DIFY_EMBED_SCRIPT_SRC.trim() !== '') {
      cleanupChatbotElements();

      const configScript = document.createElement('script');
      configScript.id = 'dify-chatbot-config';
      configScript.nonce = (window as any).__CSP_NONCE__ || ''; // Use global nonce
      const chatbotWindowConfig: { token: string; baseUrl?: string; system_variables: Record<string, any>; dynamicScript?: boolean } = {
        token: chatbotConfigToken!,
        baseUrl: chatbotConfigBaseUrl,
        system_variables: {},
        dynamicScript: true,
      };
      if (chatbotSystemVariables && Array.isArray(chatbotSystemVariables)) {
        chatbotSystemVariables.forEach(sv => {
          if (sv.key && sv.value !== undefined) {
            chatbotWindowConfig.system_variables[sv.key] = sv.value;
          }
        });
      }
      configScript.innerHTML = `window.difyChatbotConfig = ${JSON.stringify(chatbotWindowConfig)};`;
      document.head.appendChild(configScript);

      if (chatbotConfigCustomCss) {
        const styleElement = document.createElement('style');
        styleElement.id = 'chatbot-custom-style';
        styleElement.textContent = chatbotConfigCustomCss;
        styleElement.nonce = (window as any).__CSP_NONCE__ || ''; // Use global nonce
        document.head.appendChild(styleElement);
      }

      if (chatbotConfigCustomJs) {
        const customScriptElement = document.createElement('script');
        customScriptElement.id = 'chatbot-custom-js';
        customScriptElement.textContent = chatbotConfigCustomJs;
        customScriptElement.nonce = (window as any).__CSP_NONCE__ || ''; // Use global nonce
        document.head.appendChild(customScriptElement);
      }

      const embedScript = document.createElement('script');
      embedScript.src = DIFY_EMBED_SCRIPT_SRC;
      embedScript.id = scriptIdToUse;
      embedScript.defer = true;
      embedScript.onload = () => {
      };
      embedScript.onerror = () => {
      };
      document.head.appendChild(embedScript);

    } else {
      cleanupChatbotElements();
    }

    return () => {
      cleanupChatbotElements();
    };
  }, [
    chatbotIsLoading,
    chatbotIsEnabled,
    chatbotIsConfigured,
    chatbotConfigToken,
    chatbotConfigBaseUrl,
    chatbotConfigCustomCss,
    chatbotConfigCustomJs,
    chatbotSystemVariablesJson,
  ]);
  // --- AI Chatbot Integration useEffect End ---

  return (
    // <React.StrictMode> // StrictMode in main.tsx is already commented out
      <QueryClientProvider client={queryClient}>
        <App>
          <RouterProvider router={router} />
        </App>
      </QueryClientProvider>
    // </React.StrictMode>
  );
};

export default AppWrapper; 