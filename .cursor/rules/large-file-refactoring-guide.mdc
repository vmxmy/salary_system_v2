# 大型文件重构规范指南

## 📋 重构触发条件

### 强制重构阈值
- **单文件超过 800 行**: 必须立即规划重构
- **单文件超过 1000 行**: 禁止继续添加功能，优先重构
- **单函数超过 100 行**: 考虑拆分子函数
- **单组件超过 500 行**: 考虑组件拆分

### 重构信号识别
- 🚨 **职责混乱**: 文件承担多个不相关功能
- 🚨 **难以定位**: 查找特定功能需要大量滚动
- 🚨 **修改风险**: 改动一个功能影响其他功能
- 🚨 **团队协作**: 多人同时修改同一文件产生冲突

## 🎯 重构规划流程

### 第一阶段：分析与设计 (必须完成)

#### 1. 功能映射分析
```typescript
// 记录当前文件的所有功能模块
const functionMap = {
  dataUpload: ['文件上传', '格式验证', '编码处理'],
  smartMapping: ['字段映射', '置信度计算', '映射规则'],
  dataPreview: ['数据验证', '错误显示', '预览表格'],
  importExecution: ['批量导入', '结果展示', '错误处理']
};
```

#### 2. 职责分组原则
- **单一职责**: 每个模块只负责一个业务领域
- **高内聚**: 相关功能集中在同一模块
- **低耦合**: 模块间通过明确接口通信
- **可测试**: 每个模块可独立测试

#### 3. 依赖关系梳理
```mermaid
graph TD
    A[主控制器] --> B[数据上传]
    A --> C[智能映射] 
    A --> D[数据预览]
    A --> E[导入执行]
    B --> F[文件处理工具]
    C --> G[字段映射工具]
```

### 第二阶段：模块拆分 (严格执行)

#### 1. 目录结构设计
```
ComponentName/
├── ComponentNameV2.tsx          (主控制器, <200行)
├── types/
│   ├── index.ts                 (类型定义, <150行)
│   └── constants.ts             (常量配置, <150行)
├── components/                  (UI组件目录)
│   ├── ModuleA.tsx             (<300行)
│   ├── ModuleB.tsx             (<300行)
│   └── ModuleC.tsx             (<300行)
├── utils/                       (工具函数目录)
│   ├── businessLogic.ts        (<200行)
│   └── dataProcessing.ts       (<200行)
└── hooks/                       (状态管理目录)
    └── useBusinessFlow.ts      (<250行)
```

#### 2. 拆分顺序 (推荐)
1. **提取类型定义** → `types/index.ts`
2. **提取常量配置** → `types/constants.ts`
3. **提取工具函数** → `utils/`
4. **提取UI组件** → `components/`
5. **创建状态管理** → `hooks/`
6. **重构主控制器** → `ComponentV2.tsx`

#### 3. 单文件大小控制
- **类型文件**: 50-150 行
- **常量文件**: 50-150 行
- **工具函数**: 100-200 行
- **UI组件**: 150-300 行
- **Hook**: 150-250 行
- **主控制器**: 100-200 行

### 第三阶段：代码迁移 (分步进行)

#### 1. 类型定义迁移
```typescript
// types/index.ts - 统一类型定义
export interface ImportData {
  headers: string[];
  rows: any[][];
  totalRecords: number;
}

export interface MappingRule {
  sourceField: string;
  targetField: string;
  confidence: number;
  category: string;
  required: boolean;
}
```

#### 2. 常量配置迁移
```typescript
// types/constants.ts - 配置集中管理
export const STEPS_CONFIG = [
  {
    title: '数据准备',
    description: '上传或输入薪资数据',
    icon: <CloudUploadOutlined />,
    content: 'upload'
  }
  // ...
];

export const DEFAULT_IMPORT_SETTINGS = {
  skipInvalidRecords: true,
  overwriteExisting: false,
  sendNotification: true
};
```

#### 3. 状态管理集中
```typescript
// hooks/useBusinessFlow.ts - 状态集中管理
export const useBusinessFlow = () => {
  const [currentStep, setCurrentStep] = useState(0);
  const [loading, setLoading] = useState(false);
  // ... 其他状态
  
  return {
    // 状态
    currentStep,
    loading,
    // 操作
    setCurrentStep,
    handleAction,
    resetFlow
  };
};
```

## 🔧 重构最佳实践

### 组件设计原则

#### 1. Props接口设计
```typescript
interface ComponentProps {
  // 数据输入
  data: InputData;
  // 配置选项
  options: ConfigOptions;
  // 回调函数
  onAction: (result: ActionResult) => void;
  onError: (error: Error) => void;
  // 状态控制
  loading?: boolean;
  disabled?: boolean;
}
```

#### 2. 组件职责分离
- **容器组件**: 负责数据获取和状态管理
- **展示组件**: 负责UI渲染和用户交互
- **工具组件**: 负责特定功能的封装

#### 3. 错误边界处理
```typescript
// 每个模块都应有错误处理
const ModuleComponent: React.FC<Props> = ({ onError }) => {
  try {
    // 业务逻辑
  } catch (error) {
    console.error('❌ Module error:', error);
    onError?.(error);
  }
};
```

### 状态管理策略

#### 1. Hook设计模式
```typescript
// 自定义Hook集中管理复杂状态
const useComplexFlow = () => {
  // 本地状态
  const [step, setStep] = useState(0);
  
  // 业务逻辑
  const handleNextStep = useCallback(() => {
    setStep(prev => prev + 1);
  }, []);
  
  // 暴露接口
  return { step, handleNextStep };
};
```

#### 2. 状态同步原则
- **单向数据流**: 状态从上级传递到下级
- **回调通信**: 下级通过回调通知上级状态变化
- **最小状态**: 只在必要的层级维护状态

## ⚠️ 重构注意事项

### 迁移风险控制

#### 1. 向后兼容
- 保持原有API接口不变
- 分阶段迁移，确保每阶段可回滚
- 保留原文件作为备份

#### 2. 功能完整性
- 确保所有原功能都有对应的新模块
- 验证数据流和状态管理的正确性
- 测试边界情况和错误处理

#### 3. 性能考虑
- 避免过度拆分导致的prop drilling
- 合理使用React.memo优化重渲染
- 考虑代码分割和懒加载

### 团队协作规范

#### 1. 拆分前沟通
- 与团队成员确认拆分计划
- 评估对其他模块的影响
- 制定迁移时间表

#### 2. 代码审查要点
- 检查模块职责是否清晰
- 验证接口设计的合理性
- 确认文件大小符合规范

#### 3. 文档更新
- 更新组件使用文档
- 记录重构决策和原因
- 提供迁移指南

## 📊 重构效果评估

### 成功标准
- ✅ 所有文件小于800行（目标<500行）
- ✅ 每个模块职责单一清晰
- ✅ 模块间耦合度低
- ✅ 代码可读性和可维护性提升
- ✅ 团队开发效率提高

### 量化指标
- **文件行数**: 减少60%以上
- **圈复杂度**: 每个函数<10
- **模块内聚度**: >80%
- **模块间耦合度**: <20%

## 🎯 重构检查清单

### 拆分前检查
- [ ] 确认触发重构的条件
- [ ] 完成功能映射和职责分析  
- [ ] 设计模块结构和接口
- [ ] 评估重构风险和时间成本

### 拆分过程检查
- [ ] 类型定义提取完整
- [ ] 常量配置集中管理
- [ ] 工具函数正确迁移
- [ ] UI组件职责清晰
- [ ] 状态管理集中有效

### 拆分后验证
- [ ] 所有模块文件大小符合规范
- [ ] 功能完整性验证通过
- [ ] 错误处理覆盖完整
- [ ] 团队代码审查通过
- [ ] 相关文档已更新

---

**参考案例**: [PayrollBulkImportPageV3.tsx](mdc:frontend/v2/src/pages/Payroll/pages/PayrollBulkImportPage/PayrollBulkImportPageV3.tsx) → [PayrollBulkImportPageV4.tsx](mdc:frontend/v2/src/pages/Payroll/pages/PayrollBulkImportPage/PayrollBulkImportPageV4.tsx)

**重构实践**: 2063行巨型文件成功拆分为11个专业模块，平均文件大小161行，实现了代码质量的显著提升。
